
* Install
  https://askubuntu.com/questions/670304/what-is-the-install-routine-for-common-lisp-slime-sbcl-quicklisp-on-ubuntu
  https://lispcookbook.github.io/cl-cookbook/getting-started.html
** install sbcl
   $ sudo apt-get install sbcl
   $ sudo apt install sbcl-source  # necessary for "slime-edit-definition" (M-.)
   or
   $ conda install -c conda-forge sbcl
** install quicklisp
   https://www.quicklisp.org/
   copy and past the code in the gray box of the website (https://www.quicklisp.org/)

   Below is the summary (written at 2020.11.19):
   $ curl -O https://beta.quicklisp.org/quicklisp.lisp
   $ curl -O https://beta.quicklisp.org/quicklisp.lisp.asc
   $ gpg --verify quicklisp.lisp.asc quicklisp.lisp
   $ sbcl --load quicklisp.lisp
   * (quicklisp-quickstart:install)
   * (ql:system-apropos "vecto")
   * (ql:quickload "vecto")
   * (ql:add-to-init-file)
   * (quit)
** install slime by using quicklisp
   $ sbcl
   * (ql:quickload "quicklisp-slime-helper")
   * (quit)
** after installing slime, it will say following:
   - To use, add this to your ~/.emacs:
     (load (expand-file-name "~/quicklisp/slime-helper.el"))
     ;; Replace "sbcl" with the path to your implementation
     (setq inferior-lisp-program "path/to/sbcl")
   - you can get the path by "which sbcl"
** M-x slime
** run a script file in command line
   $ sbcl --script source.lisp

* Debian
** library install
   https://wiki.debian.org/CommonLisp
   there are two ways to install libraries in debian
   - via apt
     - once a system has been installed, it can be loaded with "require"
       - "asdf" should be loaded beforehand by (require "asdf")?
   - via quicklisp
     - "ql:quickload" tries downloading then loads a system
     - once a system has been installed, it can be loaded with "require"
       - "quicklisp" should be loaded beforehand
       - quicklisp can be loaded by (load "~/quicklisp/setup.lisp")
         unless "~/.sbclrc" is not updated by (ql:add-to-init-file)

* SLIME
** Emacs SLIME commands
   - slime : runs REPL
   - slime-repl-quit
   - slime-quit-lisp
   - slime-edit-definition (M-.) : go to definition from slime REPL
     The source code should be loaded to find definitions (e.g. slime-load-system, slime-load-file)
     ( https://slime-devel.common-lisp.narkive.com/aqHOQt9W/problem-with-slime-edit-definition )
   - slime-sync-package-and-default-directory (C-c ~) : it will change
     the current package of the REPL to the package of that file and
     also set the current directory of the REPL to the parent
     directory of the file
   - slime-reindent-defun
*** Completion
    - C-c TAB (completion-at-point)
    - M-/ (dabbrev-expand)
*** Compilation vs Evaluation
    https://lispcookbook.github.io/cl-cookbook/emacs-ide.html#evaluating-and-compiling-lisp-in-slime
    There are a couple of pragmatic differences when choosing between
    compiling or evaluating. In general, it is better to compile
    top-level forms, for two reasons:
    - Compiling a top-level form highlights warnings and errors in the editor, whereas evaluation does not.
    - SLIME keeps track of line-numbers of compiled forms, but when a
      top-level form is evaluated, the file line number information is
      lost. That’s problematic for code navigation afterwards.
*** compilation
    https://lispcookbook.github.io/cl-cookbook/emacs-ide.html#evaluating-and-compiling-lisp-in-slime
    - C-c C-k (slime-compile-and-load-file)
    - M-x slime-compile-region
    - C-c C-c (slime-compile-defun)
*** Evaluation (not compilation)
    https://lispcookbook.github.io/cl-cookbook/emacs-ide.html#evaluating-and-compiling-lisp-in-slime
    - C-x C-e (slime-eval-last-expression) : the result is printed in the minibuffer.
    - C-c C-p (slime-pprint-eval-last-expression) : eval and pretty-print the expression before point
    - C-c C-r : evaluate a region
    - C-M-x : evaluate a defun
    - C-c C-e (slime-interactive-eval) : get a prompt that asks for code to eval in the current context
    - C-c C-j (slime-eval-last-expression-in-repl): send this expression to the REPL and evaluate it
*** Finding referece source
    https://lispcookbook.github.io/cl-cookbook/emacs-ide.html#searching-lisp-code
    - C-c C-w c (slime-who-calls) : callers of a function
    - C-c C-w m (slime-who-macroexpands) : places where a macro is expanded
    - C-c C-w r (slime-who-references) : global variable references
    - C-c C-w b (slime-who-bind) : global variable bindings
    - C-c C-w s (slime-who-sets) : global variable setters
    - C-c C-w a (slime-who-specializes) : methods specialized on a symbol
*** Documentation
    https://lispcookbook.github.io/cl-cookbook/emacs-ide.html#lisp-documentation-in-emacs---learning-about-lisp-symbols
    - C-c C-d d : shows the symbols’ documentation on a new window
      it's the same result using "describe" function
    - C-c C-d f : describes a function
    - C-c C-d h : looks up the symbol documentation in CLHS by opening the web browser.
      however, it works only on symbols, so there are two more bindings:
      - C-c C-d # : for reader macros
      - C-c C-d ~ : for format directives
*** Resource
    - The Common Lisp Cookbook
      https://lispcookbook.github.io/cl-cookbook/emacs-ide.html
      - SLIME REPL shortcuts
        https://lispcookbook.github.io/cl-cookbook/emacs-ide.html#all-slime-repl-shortcuts
      - SLIME mode shortcuts
        https://lispcookbook.github.io/cl-cookbook/emacs-ide.html#all-other-slime-shortcuts
    - Useful SLIME shortcuts
      https://www.youtube.com/watch?v=sBcPNr1CKKw
** Debugging
*** Functions        
    - (error "message" ...): shows backtrace
    - (break): go into a debugger
*** interactive debugger shortcuts
    pressing the following shortcuts on a stack trace frame provide debugging information
    - v (sldb-show-source) shows the corresponding source file location
    - e (sldb-eval-in-frame) evaluates an expression on the frame
    - d (sldb-pprint-eval-in-frame) evaluates an expression on the frame with pretty format
*** Stepping
    0. [[*Compile with different optimizations][compile with maximum debugging information]]
       e.g. "C-u C-c C-c"
    1. The function to debug should inclue "(break)"
       or run the function with "step"
       https://www.reddit.com/r/lisp/comments/1q42pc/comment/cd92k9i/?utm_source=share&utm_medium=web2x&context=3
       e.g.
       #+begin_example
       CL-USER> (step (some-func arg1 arg2))
       #+end_example
    2. Choose "STEP-INTO" to go inside the function
    3. Now, you can use STEP-CONTINUE, STEP-OUT, STEP-NEXT and STEP-INTO
*** SLDB: the SLIME debugger
    https://slime.common-lisp.dev/doc/html/Debugger.html
*** slime-repl-inspect (C-c I)
    inspect an object, such as a variable, function or class
    (you can call "(inspect 'symbol)" instead on REPL)
*** trace & untrace
    https://lispcookbook.github.io/cl-cookbook/debugging.html#trace
**** trace
     when a traced function is called, it shows the all other function calls until the traced function is terminated
     e.g.
     #+begin_src lisp
     (defun factorial (n)
       (if (plusp n)
           (* n (factorial (1- n)))
           1))
     (trace factorial)

     (factorial 2)
     #+end_src
*** untrace
    an untraced function doesn't show its internal function calls anymore
    e.g.
    #+begin_src lisp
    (untrace factorial)
    #+end_src

    you can untrace all functions by passing no argument to "untrace"
    e.g.
    #+begin_src lisp
    (untrace)
    #+end_src
*** tracing with slime
**** slime-trace-dialog-toggle-trace (C-c M-t)
     you can toggle to trace/untrace a function with the slime command
**** slime-trace-dialog (C-c T)
     it manages and showa tracing information
     shortcuts:
     - slime-trace-dialog-fetch-status (g): update status
     - slime-trace-dialog-fetch-traces (G): update traces
*** tracing recursive functions
    recursive functions may not be traced due to optimization
    in that case the optimization level should be lowered to trace recursion:
    #+begin_src lisp
    (declaim (optimize (debug 3)))
    #+end_src
*** tracing method invocation
    https://lispcookbook.github.io/cl-cookbook/debugging.html#tracing-method-invocation
    #+begin_src lisp
    (trace foo :methods t)
    #+end_src
** Compile with different optimizations
   https://lispcookbook.github.io/cl-cookbook/debugging.html#compile-with-maximum-debugging-information
   - C-u C-c C-c: compile with maximum debugging information
     cf. optimization option
     #+begin_src lisp
     (declaim (optimize (speed 0) (space 0) (debug 3)))
     #+end_src
   - M-- C-c C-c: compile for speed

* CFFI
  - tutorial: https://www.youtube.com/watch?v=lvHi5LyhxGk

* Note
** Function arguments
   http://www.gigamonkeys.com/book/functions.html
   addtional arguments: optional, rest, keyword
** function(#') and lambda
   https://stackoverflow.com/a/29346982/6710003

   The results of following expresions are same:
   > #'(lambda ...)
   > (function (lambda ...))
   > (lambda ...)

   because lambda is a macro and the expanded form include function:
   > (macroexpand-1 '(lambda (x) (+ x x x)))
   ==> (function (lambda (x) (+ x x x)))
** Macro
   - examples: https://lispcookbook.github.io/cl-cookbook/macros.html
** package
   http://www.flownet.com/gat/packages.pdf
   https://lispcookbook.github.io/cl-cookbook/packages.html

   - a package is a collection of symbols of distinct names
   - a package cannot have symbols with the same name
   - packages cannot have a same name.
*** current package
    a special variable ~*package*~ indicate the current package
    #+begin_src lisp
    ,*package*
    #+end_src
*** initial package
    common-lisp-user is the inital package
*** making a package
    a new package cange defined by 'defpackage'.
    however, the command doesn't switch to the new package.
    #+begin_src lisp
    (defpackage :my-package
      (:use :cl))
    #+end_src
    (also, package can be created by 'make-package' function, which is used defpackage)
**** defpackage
     - all of functionalieis about importing, exporting, shadowing, etc, can be processed by 'defpackage'
     - you should not use other functions except 'defpackage'
     - the arguments could be symbols, strings, keywords, etc,
       however, you should refrain to pass symbols as arguments. otherwise, symbols would be interned before passing themselves as arguments
*** switching package
    change the current package by 'in-package' macro
    #+begin_src lisp
    (in-package :my-package)
    #+end_src
*** accessing symbols in packages
    - package:exported-symbol
    - package::non-exported-symbol.
*** importing symbols in other packages
**** importing a symbol
     #+begin_src lisp
     (import 'some-package::some-function)
     (some-function)
     #+end_src
***** import a list of symbols
      #+begin_src lisp
      (defpackage :some-package (:use :cl))
      (in-package :some-package)
      (defvar *symbols* '(foo bar))
      (in-package :common-lisp-user)
      (import some-package::*symbols*)  ; import 'foo and 'bar
      (import 'some-package::*symbols*)  ; import '*symbols*
      #+end_src
**** importing a symbol for package definition
     #+begin_src lisp
     (defpackage :my-package
       (:import-from :some-package :func1 #:func2)
       (:use :cl))
     #+end_src
     - 'my-package' shares symbols 'func1' and 'func2' with package 'some-package'
     - packages and symbols can be expressed as keywords or sharpsign colon (#:some-name) forms
     - if ":import-from" include only a package without addtional arguments, it doesn't import anything
       however, recent ASDF can detect the dependency and load the system including the package
       https://asdf.common-lisp.dev/asdf.html#The-package_002dinferred_002dsystem-extension
     - "(:use :cl)" is needed to use exported symbols from "cl" package
**** importing all symbols for package definition
     #+begin_src lisp
     (defpackage :my-package
       (:use :cl :ppcre))
     #+end_src
     all symbols exported from 'cl' and 'ppcre' are available in 'my-package'.
     however, exploit 'use' only for importing symbols of your internal packages which you can control.
**** printing all exported packages
     #+begin_src lisp
     (let ((package-name "CL"))  ; the name should be capitalized
       (do-external-symbols (s (find-package package-name))
         (print s)))
     #+end_src
**** name conflicts of symbols
     #+begin_src lisp
     (defpackage :some-package
       (:use :cl))
     (in-package :some-package)
     (defun some-function ()
       "some-function")
     (in-package :common-lisp-user)
     (intern "SOME-FUNCTION")  ; interning a symbol of same name
     (import 'some-package::some-function)  ; raise an error
     #+end_src
*** home package
    every symbol has a unique home package.

    in the below example, home package of 'foo is 'jane, although 'foo is also interned in 'bob
    #+begin_src lisp
    (defpackage :jane (:use :cl))
    (in-package :jane)
    'foo
    (defpackage :bob (:use :cl))
    (in-package bob)
    (import 'jane::foo)
    (defpackage :charlie (:use :cl))
    (in-package charlie)
    (print 'bob::foo)  ; (symbol-package 'bob::foo) => #<PACKAGE "JANE">
    #+end_src
**** symbol-package
     'symbol-package' is return the home package of a symbol
     #+begin_src lisp
     (symbol-package some-symbol)
     (symbol-package 'symbol-name)
     (symbol-package 'package-name::symbol-name)
     #+end_src
*** exporting
    related operations:
    - export : add a symbol to the exported symbol list
    - unexport : pop a symbol from the exported symbol list
    - use-package : import all the exported symbols in a package
    - unuse-package : unimport all the exported symbols in a package
**** shadowing
     - a symbol added to the "shadowing symbols list" shadow or override symbols with the same name
     (shadowing is used when use-package is called multiples times over packages exporting symbols with the same names)
     - shadowing should be carefuly used
       https://www-fourier.ujf-grenoble.fr/~sergerar/Papers/Packaging.pdf
     - shadowing functions
       - shadow: add a symbol into "shadowing symbols list" of a package (and intern the symbol if it wasn't),
         then the package always use the symbol and doesn't use symbols with the same name from other packages
       - shadowing-import: import a symbol from another package and the symbol shadow other symbols with the same name.
     - 'unintern' cancel the effect of 'shadow' and 'shadowing-import'
       'unintern' could raise name conflicts

     #+begin_src lisp
     (defpackage :p1 (:use :cl))
     (in-package :p1)
     (export '(x y z))

     (defpackage :p2 (:use :cl))
     (in-package :p2)
     (export '(x y z))

     (defpackage :main (:use :cl))
     (in-package :main)

     (shadow 'x)  ; (shadow 'x 'main) or (shadow "X")
     (shadow "Y")  ; (find-symbol "Y") => :INTERNAL
     (shadowing-import 'p1:y)  ; shadowing and import
     (shadowing-import 'p2:z)  ; shadowing and import

     (use-package 'p1)
     (use-package 'p2)

     (print (symbol-package 'x))  ; #<PACKAGE "MAIN">
     (print (symbol-package 'y))  ; #<PACKAGE "P1">
     (print (symbol-package 'z))  ; #<PACKAGE "P2">

     ;; (unintern 'x)  ; => name conflicts between 'p1:x and 'p2:x
     #+end_src
**** exporting imported symbols
     a package can export symbols which are imported from other packages
     #+begin_src lisp
     (defpackage :test-hwp (:use :cl :alexandria) (:export :copy-array))
     #+end_src
** symbol
*** interning a symbol
    http://www.flownet.com/gat/packages.pdf
    interning a symbol is an act of putting a symbol into a package
**** functions related to interning
***** import
      'import' add a symbol into a package, so it does interning
      #+begin_src lisp
      (setq some-symbol (make-symbol "SOME-NAME"))
      (print some-symbol)
      (import some-symbol)
      (print some-symbol)
      (eq some-symbol 'some-name)
      #+end_src
***** unintern
      'unintern' remove a symbol from a package.
      it's a reverse operation of 'import'
      #+begin_src lisp
      (setq some-symbol 'some-name)
      (unintern some-symbol)
      (eq some-symbol 'some-name)  ; 'some-name is the newly interned symbol which is different with some-symbol
      ;; (import some-symbol)  ; name-conflict error
      #+end_src
***** intern
      'intern' take a name and make a symbol of the name and import it
      if a symbol with the same name doesn't exist

      definition of intern like:
      #+begin_src lisp
      (defun intern (name)
        (or (find-symbol name)
            (let ((s (make-symbol name)))
              (import s)
              s)))
      #+end_src
***** symbol-name
      'symbol-name' takes a symbol and return its name
      #+begin_src lisp
      (symbol-name 'cl:car)
      (symbol-name 'car)
      #+end_src
***** symbol-package
      'symbol-package' returns the home package of a symbol
      #+begin_src lisp
      (symbol-package 'cl:car)
      (symbol-package 'car)
      #+end_src
**** uninterned symbol
     making uninterned symbols
     - an uninterned symbol with a uniqure name can be created by 'gensym'
     - an uninterned symbol with a given string can be created by 'make-symbol'
     - or you can make a specific symols like #:some-name
     #+begin_src lisp
     (gensym)
     (make-symbol "SOME-NAME")
     (setf #:some-name 100)
     #+end_src
***** sharpsign colon (#:some-name)
     http://clhs.lisp.se/Body/02_dhe.htm
     "#:" introduces an uninterned symbol whose name is
     symbol-name. Every time this syntax is encountered, a distinct
     uninterned symbol is created. The symbol-name must have the
     syntax of a symbol with no package prefix.

     http://www.flownet.com/gat/packages.pdf
     Usually symbol with "#:" is uninterned symbol,
     but the exact meaning of "#:" is a symbol without "home package".
     There is a rare case of "#:", where a symbol is interned for a package but doesn't have a home package.

     #+begin_src lisp
     (defpackage :jane (:use :cl))
     (in-package :jane)
     'foo
     (defpackage :bob (:use :cl))
     (in-package bob)
     (import 'jane::foo)
     (in-package :jane)
     (unintern 'foo)
     (print (symbol-package 'bob::foo))  ; => NIL
     (print 'bob::foo)  ; => #:FOO
     #+end_src
***** equality between uninterned symbols
      'make-symbol' make different symbols although the name is same
      #+begin_src lisp
      (setq symbol1 (make-symbol "MY-SYMBOL"))
      (setq symbol2 (make-symbol "MY-SYMBOL"))
      (eq symbol1 symbol2)  ; => NIL

      (setq symbol3 'my-symbol)  ; 'my-symbol is a symbol made from Lisp reader, which use make-symbol
      (setq symbol4 'my-symbol)  ; doesn't make a new symbol and return 'my-symbol
      (eq symbol3 symbol4)  ; => T ; two symbols are same
      #+end_src
**** finding an interned symbol
     #+begin_src lisp
     (find-symbol "SOME-NAME")  ; the name should be capitalized
     #+end_src
**** uninterned symbols can be used for packages
     https://lispcookbook.github.io/cl-cookbook/packages.html
     https://microeducate.tech/uninterned-symbols-in-common-lisp/
     #+begin_src lisp
     (defpackage #:iterate
       (:use :cl)
       (:nicknames #:iter))

     (print "ITERATE")
     (print "ITER")

     (in-package #:iter)
     #+end_src
*** sharping dot (#.)
    https://stackoverflow.com/a/59003160
    sharpsign dot (#.) evaluates the next expression at read time
    #+begin_src lisp
    (defvar *some-var* 42)
    (print '(*some-var* #.*some-var*))
    (print '(*some-var* (* #.*some-var* pi) #.(* pi *some-var*)))
    #+end_src
** system
   https://sinax.be/blog/lisp/getting-started-with-asdf.html
*** loading system
    #+begin_src lisp
    (asdf:load-system "alexandria")
    #+end_src
**** asdf:make
     https://asdf.common-lisp.dev/asdf/Convenience-Functions.html
     "asdf:make" also load files like "asdf:load-system" as the default behavior,
     but system definition can change the behavior
     #+begin_src lisp
     (asdf:make "alexandria")
     #+end_src
*** standard location of systems
    ~/common-lisp/
    ~/.local/share/common-lisp/source/
*** dependency
    https://stackoverflow.com/a/19739782
    ":depends-on" keyword is used for dependencies between systems, files or etc
    systems (or files) which are depended on are loaded earlier than other systems or files
*** module
    lisp files can be split into multiple directories, then each directory become a module
    e.g. https://gitlab.common-lisp.net/alexandria/alexandria

    c.f.
    - each module doesn't need to belong to a specific package
    - symbols' belonging to packages are defined by utilities such as 'defpackage'
    - location of symbols in modules or files don't decide their packages
*** Load new system created during runtime
    https://lispcookbook.github.io/cl-cookbook/systems.html#using-the-system-you-defined
    - load the new .asd file: (load "path/to/foobar.asd"),
      or with C-c C-k in Slime to compile and load the whole file.
    - (asdf:clear-configuration) to re-process the configuration.
*** add directories where ASDF search systems
    https://asdf.common-lisp.dev/asdf/Configuring-ASDF-to-find-your-systems.html
    https://asdf.common-lisp.dev/asdf/Controlling-where-ASDF-searches-for-systems.html
    the default directories of systems:
    - ~/common-lisp/
    - ~/.local/share/common-lisp/source/.

    if you want to add another directory:
    1. make directory "~/.config/common-lisp/source-registry.conf.d/"
    2. make a file named "*.conf" in the directory
       e.g. "my-lisp.conf"
    3. add the following line into the file
       #+begin_src lisp
       (:tree "/home/user/my-lisp/")
       #+end_src
*** creating a project skeleton
    #+begin_src lisp
    (ql:quickload "cl-project")
    (cl-project:make-project #p"some/path/to/project/")  ; if you doesn't use an absolute path, the project directory is created from the current path for slime
    #+end_src
*** testing a system
    #+begin_src lisp
    (asdf:test-system :some-project)
    #+end_src

    for testing, a testing system should be defined in the system's .asd file
    (the test skeleton is also created by "cl-project:make-project")
    e.g.
    #+begin_src lisp
    (defsystem "some-project"
      ...)
    (defsystem "some-project/tests"
      ...)
    #+end_src
** quicklisp
*** install and load systems
    #+begin_src lisp
    (ql:quickload "some-system")
    #+end_src
    the system "some-system" installed in "~/quicklisp/dists/quicklisp/software/"
** comment
*** #+(or) & #+(and)
    https://stackoverflow.com/a/6365579 
    https://lispcookbook.github.io/cl-cookbook/debugging.html#using-the-powerful-repl
    #+(or) comment the following expression
    #+(and) doesn't comment the following expression
    #+begin_src lisp
    (progn
      #+(or)
      (defun func-1 ())  ; undefined
      #+(and)
      (defun func-2 ())  ; defined
      )
    #+end_src    

    ~#+nil~ works too but there are exceptional cases
    ( https://stackoverflow.com/a/6365579 )
*** #| ... |#
    https://lispcookbook.github.io/cl-cookbook/debugging.html#using-the-powerful-repl

    the code in #| ... |# is commented
** miscellaneous
*** asterisks(*) variable
    https://stackoverflow.com/a/34595750
    - * refers the last value retured by REPL
** string and characters
*** character representation: #\[some-char]
    e.g.
    #+begin_src lisp
    ;; https://lispcookbook.github.io/cl-cookbook/data-structures.html#substitute-nsubstituteifif-not
    (substitute #\o #\x "hellx") ;; => "hello"
    #+end_src

* Lisp functions and utilities
** (load "file-path.ext")
** (apropos "some-substring")
   search for interned symbols whose names contain the substring
** print & read
   https://lispcookbook.github.io/cl-cookbook/debugging.html
   "print" prints a readable representation of its argument,
   which means what is printed can be read back in by the Lisp reader.
** princ
   https://lispcookbook.github.io/cl-cookbook/debugging.html
   "princ" focuses on an aesthetic representation.
** comparison of print functions
   https://stackoverflow.com/a/19756405
   - "write" is the general entry point to the Lisp printer.
   - "prin1" produces output suitable for input to read.
   - "princ" is just like prin1 except that the output has no escape characters. princ is intended to look good to people, while output from prin1 is intended to be acceptable for the function read.
   - "print" is just like prin1 except that the printed representation of object is preceded by a newline and followed by a space.
   - "pprint" produces pretty output.
** format
   "format" prints (with t as the 1st argument) or returns a string (with nil as the 1st argument)
   #+begin_src lisp
   (format t "it prints - ~a ~a" "some string" 100)  ; print a string and return nil
   (format nil "it's a string - ~a ~a" "some string" 100)  ; return a string
   #+end_src
*** format directives
    https://en.wikipedia.org/wiki/Format_(Common_Lisp)#Format_directives
*** iteration construct (~{str~})
    https://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node200.html
    #+begin_src lisp
    (format nil 
            "The winners are:~{ ~S~}." 
            '(fred harry jill)) 
    ;; => "The winners are: FRED HARRY JILL." 

    (format nil "Pairs:~{ <~S,~S>~}." '(a 1 b 2 c 3)) 
    ;; => "Pairs: <A,1> <B,2> <C,3>."
    #+end_src
** destructuring-bind
   - examples
     https://gigamonkeys.com/book/beyond-lists-other-uses-for-cons-cells.html
** set
*** a list to a set
    https://stackoverflow.com/a/34003369
    e.g.
    #+begin_src lisp
    (remove-duplicates '(a b c b d d e))
    (remove-duplicates '("foo" "bar" "bar" "foo" "baz" "foo") :test #'string=)
    ;; (remove-duplicates '("foo" "bar" "bar" "foo" "baz" "foo")) ; it doesn't remove duplicate strings
    #+end_src
*** set functions
    https://lispcookbook.github.io/cl-cookbook/data-structures.html#set
** array and vector
   https://lispcookbook.github.io/cl-cookbook/data-structures.html#arrays-and-vectors
   https://stackoverflow.com/a/28908613

   - a vector is an one-dimensional array
     - a vector is also a sequence
   - a simple-array is an array which
     - are not displaced (by :displaced-to)
     - are not adjustable (by :adjust-array)
     - have no fill pointer (by fill-pointer)
   - a simple-vector is a simple-array which does not restrict its types of elements
     - it doesn’t use :element-type to set the types of the elements
*** array and vector notation
    #+begin_src lisp
    ;; 1 dimensional
    (type-of #(1 1 1))  ; => (SIMPLE-VECTOR 3)
    (type-of '#(1 1 1))  ; => (SIMPLE-VECTOR 3)
    (type-of #1A(1 1 1))  ; => (SIMPLE-VECTOR 3)
    (type-of (vector 1 1 1))  ; => (SIMPLE-VECTOR 3)

    ;; 2 dimensional
    (type-of #2A((1 1) (1 1)))  ; => (SIMPLE-ARRAY T (2 2))
    (type-of (make-array '(2 2) :initial-element 1))  ; => (SIMPLE-ARRAY T (2 2))

    ;; 3 dimensional
    (type-of #3A(((1 1) (1 1)) ((1 1) (1 1))))  ; => (ARRAY T (2 2 2))

    ;; 3 dimensional with different values of elements
    (type-of #3A(((1 2) (3 4)) ((5 6) (7 8))))  ; => (SIMPLE-ARRAY T (2 2 2))

    ;; simple vector with n elements
    #4(100)  ; => #(100 100 100 100)
    #4(100 200)  ; => #(100 200 200 200)
    (type-of #4(100))  ; => (SIMPLE-VECTOR 4)
    #+end_src
*** row-major-aref
    #+begin_src lisp
    (row-major-aref #3A(((000 001) (010 011)) ((100 101) (110 111))) 6)  ; => 110
    #+end_src
*** vector functions
    https://lispcookbook.github.io/cl-cookbook/data-structures.html#vectors
**** vector-push
     #+begin_src lisp
     (let ((vec (make-array 8 :fill-pointer 3)))
       (print vec)  ; => #(0 0 0)
       (vector-push 100 vec)
       (print vec)  ; => #(0 0 0 100)
       )
     #+end_src
**** vector-push-extend
     #+begin_src lisp
     (let ((vec (make-array 3 :fill-pointer 3)))
       (print vec)  ; => #(0 0 0)
       (print (array-total-size vec))
       (vector-push-extend 100 vec 5)  ; the optional 3rd argument means the number of added pointers when it's extended
       (print vec)  ; => #(0 0 0 100)
       (print (array-total-size vec))  ; => 8
       )
     #+end_src
**** fill-pointer
     #+begin_src lisp
     (let ((vec (make-array 8 :fill-pointer 3)))
       (print vec)  ; => #(0 0 0)
       (print (fill-pointer vec))  ; => 3
       (setf (fill-pointer vec) 1)
       (print (fill-pointer vec))  ; => 1
       (vector-push 100 vec)
       (print vec)  ; => #(0 100)
       )
     #+end_src
*** a vector to a list
    #+begin_src lisp
    (map 'list 'identity #(1 2 3))
    (coerce #(1 2 3) 'list)
    #+end_src
** association list
*** reverse order of cons as key & value
    http://clhs.lisp.se/Body/f_rassoc.htm
    https://lispcookbook.github.io/cl-cookbook/data-structures.html#hash-table
    "rassoc" uses the 2nd value of cons cell as key
