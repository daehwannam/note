
* Install
  https://askubuntu.com/questions/670304/what-is-the-install-routine-for-common-lisp-slime-sbcl-quicklisp-on-ubuntu
  https://lispcookbook.github.io/cl-cookbook/getting-started.html
** install sbcl
   $ sudo apt-get install sbcl
   $ sudo apt install sbcl-source  # necessary for "slime-edit-definition" (M-.)
   or
   $ conda install -c conda-forge sbcl
** install quicklisp
   https://www.quicklisp.org/
   copy and past the code in the gray box of the website (https://www.quicklisp.org/)

   Below is the summary (written at 2020.11.19):
   $ curl -O https://beta.quicklisp.org/quicklisp.lisp
   $ curl -O https://beta.quicklisp.org/quicklisp.lisp.asc
   $ gpg --verify quicklisp.lisp.asc quicklisp.lisp
   $ sbcl --load quicklisp.lisp
   * (quicklisp-quickstart:install)
   * (ql:system-apropos "vecto")
   * (ql:quickload "vecto")
   * (ql:add-to-init-file)
   * (quit)
** install slime by using quicklisp
   $ sbcl
   * (ql:quickload "quicklisp-slime-helper")
   * (quit)
** after installing slime, it will say following:
   - To use, add this to your ~/.emacs:
     (load (expand-file-name "~/quicklisp/slime-helper.el"))
     ;; Replace "sbcl" with the path to your implementation
     (setq inferior-lisp-program "path/to/sbcl")
   - you can get the path by "which sbcl"
** M-x slime
** run a script file in command line
   $ sbcl --script source.lisp

* Debian
** library install
   https://wiki.debian.org/CommonLisp
   there are two ways to install libraries in debian
   - via apt
     - once a system has been installed, it can be loaded with "require"
       - "asdf" should be loaded beforehand by (require "asdf")?
   - via quicklisp
     - "ql:quickload" tries downloading then loads a system
     - once a system has been installed, it can be loaded with "require"
       - "quicklisp" should be loaded beforehand
       - quicklisp can be loaded by (load "~/quicklisp/setup.lisp")
         unless "~/.sbclrc" is not updated by (ql:add-to-init-file)

* SLIME
** emacs SLIME commands
   - slime : runs REPL
   - slime-repl-quit
   - slime-quit-lisp
   - slime-edit-definition (M-.) : go to definition from slime REPL
     source code should be loaded to find definitions (e.g. slime-load-system, slime-load-file)
     https://slime-devel.common-lisp.narkive.com/aqHOQt9W/problem-with-slime-edit-definition
*** resource
    - The Common Lisp Cookbook
      https://lispcookbook.github.io/cl-cookbook/emacs-ide.html
      - slime REPL shortcuts
        https://lispcookbook.github.io/cl-cookbook/emacs-ide.html#all-slime-repl-shortcuts
      - slime mode shortcuts
        https://lispcookbook.github.io/cl-cookbook/emacs-ide.html#all-other-slime-shortcuts
    - useful slime shortcuts
      https://www.youtube.com/watch?v=sBcPNr1CKKw
** Debugging
   - (error "message" ...): shows backtrace
   - (break): go into a debugger
*** SLDB: the SLIME debugger
    https://slime.common-lisp.dev/doc/html/Debugger.html
*** slime-repl-inspect
    inspect an object, such as a variable, function or class

* CFFI
  - tutorial: https://www.youtube.com/watch?v=lvHi5LyhxGk

* Note
** Function arguments
   http://www.gigamonkeys.com/book/functions.html
   addtional arguments: optional, rest, keyword
** function(#') and lambda
   https://stackoverflow.com/a/29346982/6710003

   The results of following expresions are same:
   > #'(lambda ...)
   > (function (lambda ...))
   > (lambda ...)

   because lambda is a macro and the expanded form include function:
   > (macroexpand-1 '(lambda (x) (+ x x x)))
   ==> (function (lambda (x) (+ x x x)))
** Macro
   - examples: https://lispcookbook.github.io/cl-cookbook/macros.html
** package
   http://www.flownet.com/gat/packages.pdf
   https://lispcookbook.github.io/cl-cookbook/packages.html

   - a package is a collection of symbols of distinct names
   - a package cannot have symbols with the same name
   - packages cannot have a same name.
*** current package
    a special variable ~*package*~ indicate the current package
    #+begin_src lisp
    ,*package*
    #+end_src
*** initial package
    common-lisp-user is the inital package
*** making a package
    a new package cange defined by 'defpackage'.
    however, the command doesn't switch to the new package.
    #+begin_src lisp
    (defpackage :my-package
      (:use :cl))
    #+end_src
    (also, package can be created by 'make-package' function, which is used defpackage)
**** defpackage
     - all of functionalieis about importing, exporting, shadowing, etc, can be processed by 'defpackage'
     - you should not use other functions except 'defpackage'
     - the arguments could be symbols, strings, keywords, etc,
       however, you should refrain to pass symbols as arguments. otherwise, symbols would be interned before passing themselves as arguments
*** switching package
    change the current package by 'in-package' macro
    #+begin_src lisp
    (in-package :my-package)
    #+end_src
*** accessing symbols in packages
    - package:exported-symbol
    - package::non-exported-symbol.
*** importing symbols in other packages
**** importing a symbol
     #+begin_src lisp
     (import 'some-package::some-function)
     (some-function)
     #+end_src
***** import a list of symbols
      #+begin_src lisp
      (defpackage :some-package (:use :cl))
      (in-package :some-package)
      (defvar *symbols* '(foo bar))
      (in-package :common-lisp-user)
      (import some-package::*symbols*)  ; import 'foo and 'bar
      (import 'some-package::*symbols*)  ; import '*symbols*
      #+end_src
**** importing a symbol for package definition
     #+begin_src lisp
     (defpackage :my-package
       (:import-from :some-package :func1 #:func2)
       (:use :cl))
     #+end_src
     - 'my-package' shares symbols 'func1' and 'func2' with package 'some-package'
     - packages and symbols can be expressed as keywords or sharpsign colon (#:some-name) forms
     - if ":import-from" include only a package without addtional arguments, it doesn't import anything
       however, recent ASDF can detect the dependency and load the system including the package
       https://asdf.common-lisp.dev/asdf.html#The-package_002dinferred_002dsystem-extension
     - "(:use :cl)" is needed to use exported symbols from "cl" package
**** importing all symbols for package definition
     #+begin_src lisp
     (defpackage :my-package
       (:use :cl :ppcre))
     #+end_src
     all symbols exported from 'cl' and 'ppcre' are available in 'my-package'.
     however, exploit 'use' only for importing symbols of your internal packages which you can control.
**** printing all exported packages
     #+begin_src lisp
     (let ((package-name "CL"))  ; the name should be capitalized
       (do-external-symbols (s (find-package package-name))
         (print s)))
     #+end_src
**** name conflicts of symbols
     #+begin_src lisp
     (defpackage :some-package
       (:use :cl))
     (in-package :some-package)
     (defun some-function ()
       "some-function")
     (in-package :common-lisp-user)
     (intern "SOME-FUNCTION")  ; interning a symbol of same name
     (import 'some-package::some-function)  ; raise an error
     #+end_src
*** home package
    every symbol has a unique home package.

    in the below example, home package of 'foo is 'jane, although 'foo is also interned in 'bob
    #+begin_src lisp
    (defpackage :jane (:use :cl))
    (in-package :jane)
    'foo
    (defpackage :bob (:use :cl))
    (in-package bob)
    (import 'jane::foo)
    (defpackage :charlie (:use :cl))
    (in-package charlie)
    (print 'bob::foo)  ; (symbol-package 'bob::foo) => #<PACKAGE "JANE">
    #+end_src
**** symbol-package
     'symbol-package' is return the home package of a symbol
     #+begin_src lisp
     (symbol-package some-symbol)
     (symbol-package 'symbol-name)
     (symbol-package 'package-name::symbol-name)
     #+end_src
*** exporting
    related operations:
    - export : add a symbol to the exported symbol list
    - unexport : pop a symbol from the exported symbol list
    - use-package : import all the exported symbols in a package
    - unuse-package : unimport all the exported symbols in a package
**** shadowing
     - a symbol added to the "shadowing symbols list" shadow or override symbols with the same name
     (shadowing is used when use-package is called multiples times over packages exporting symbols with the same names)
     - shadowing should be carefuly used
       https://www-fourier.ujf-grenoble.fr/~sergerar/Papers/Packaging.pdf
     - shadowing functions
       - shadow: add a symbol into "shadowing symbols list" of a package (and intern the symbol if it wasn't),
         then the package always use the symbol and doesn't use symbols with the same name from other packages
       - shadowing-import: import a symbol from another package and the symbol shadow other symbols with the same name.
     - 'unintern' cancel the effect of 'shadow' and 'shadowing-import'
       'unintern' could raise name conflicts

     #+begin_src lisp
     (defpackage :p1 (:use :cl))
     (in-package :p1)
     (export '(x y z))

     (defpackage :p2 (:use :cl))
     (in-package :p2)
     (export '(x y z))

     (defpackage :main (:use :cl))
     (in-package :main)

     (shadow 'x)  ; (shadow 'x 'main) or (shadow "X")
     (shadow "Y")  ; (find-symbol "Y") => :INTERNAL
     (shadowing-import 'p1:y)  ; shadowing and import
     (shadowing-import 'p2:z)  ; shadowing and import

     (use-package 'p1)
     (use-package 'p2)

     (print (symbol-package 'x))  ; #<PACKAGE "MAIN">
     (print (symbol-package 'y))  ; #<PACKAGE "P1">
     (print (symbol-package 'z))  ; #<PACKAGE "P2">

     ;; (unintern 'x)  ; => name conflicts between 'p1:x and 'p2:x
     #+end_src
**** exporting imported symbols
     a package can export symbols which are imported from other packages
     #+begin_src lisp
     (defpackage :test-hwp (:use :cl :alexandria) (:export :copy-array))
     #+end_src
** symbol
*** interning a symbol
    http://www.flownet.com/gat/packages.pdf
    interning a symbol is an act of putting a symbol into a package
**** functions related to interning
***** import
      'import' add a symbol into a package, so it does interning
      #+begin_src lisp
      (setq some-symbol (make-symbol "SOME-NAME"))
      (print some-symbol)
      (import some-symbol)
      (print some-symbol)
      (eq some-symbol 'some-name)
      #+end_src
***** unintern
      'unintern' remove a symbol from a package.
      it's a reverse operation of 'import'
      #+begin_src lisp
      (setq some-symbol 'some-name)
      (unintern some-symbol)
      (eq some-symbol 'some-name)  ; 'some-name is the newly interned symbol which is different with some-symbol
      ;; (import some-symbol)  ; name-conflict error
      #+end_src
***** intern
      'intern' take a name and make a symbol of the name and import it
      if a symbol with the same name doesn't exist

      definition of intern like:
      #+begin_src lisp
      (defun intern (name)
        (or (find-symbol name)
            (let ((s (make-symbol name)))
              (import s)
              s)))
      #+end_src
***** symbol-name
      'symbol-name' takes a symbol and return its name
      #+begin_src lisp
      (symbol-name 'cl:car)
      (symbol-name 'car)
      #+end_src
***** symbol-package
      'symbol-package' returns the home package of a symbol
      #+begin_src lisp
      (symbol-package 'cl:car)
      (symbol-package 'car)
      #+end_src
**** uninterned symbol
     making uninterned symbols
     - an uninterned symbol with a uniqure name can be created by 'gensym'
     - an uninterned symbol with a given string can be created by 'make-symbol'
     - or you can make a specific symols like #:some-name
     #+begin_src lisp
     (gensym)
     (make-symbol "SOME-NAME")
     (setf #:some-name 100)
     #+end_src
***** sharpsign colon (#:some-name)
     http://clhs.lisp.se/Body/02_dhe.htm
     "#:" introduces an uninterned symbol whose name is
     symbol-name. Every time this syntax is encountered, a distinct
     uninterned symbol is created. The symbol-name must have the
     syntax of a symbol with no package prefix.

     http://www.flownet.com/gat/packages.pdf
     Usually symbol with "#:" is uninterned symbol,
     but the exact meaning of "#:" is a symbol without "home package".
     There is a rare case of "#:", where a symbol is interned for a package but doesn't have a home package.

     #+begin_src lisp
     (defpackage :jane (:use :cl))
     (in-package :jane)
     'foo
     (defpackage :bob (:use :cl))
     (in-package bob)
     (import 'jane::foo)
     (in-package :jane)
     (unintern 'foo)
     (print (symbol-package 'bob::foo))  ; => NIL
     (print 'bob::foo)  ; => #:FOO
     #+end_src
***** equality between uninterned symbols
      'make-symbol' make different symbols although the name is same
      #+begin_src lisp
      (setq symbol1 (make-symbol "MY-SYMBOL"))
      (setq symbol2 (make-symbol "MY-SYMBOL"))
      (eq symbol1 symbol2)  ; => NIL

      (setq symbol3 'my-symbol)  ; 'my-symbol is a symbol made from Lisp reader, which use make-symbol
      (setq symbol4 'my-symbol)  ; doesn't make a new symbol and return 'my-symbol
      (eq symbol3 symbol4)  ; => T ; two symbols are same
      #+end_src
**** finding an interned symbol
     #+begin_src lisp
     (find-symbol "SOME-NAME")  ; the name should be capitalized
     #+end_src
**** uninterned symbols can be used for packages
     https://lispcookbook.github.io/cl-cookbook/packages.html
     https://microeducate.tech/uninterned-symbols-in-common-lisp/
     #+begin_src lisp
     (defpackage #:iterate
       (:use :cl)
       (:nicknames #:iter))

     (print "ITERATE")
     (print "ITER")

     (in-package #:iter)
     #+end_src
*** sharping dot (#.)
    https://stackoverflow.com/a/59003160
    sharpsign dot (#.) evaluates the next expression at read time
    #+begin_src lisp
    (defvar *some-var* 42)
    (print '(*some-var* #.*some-var*))
    (print '(*some-var* (* #.*some-var* pi) #.(* pi *some-var*)))
    #+end_src
** system
   https://sinax.be/blog/lisp/getting-started-with-asdf.html
*** loading system
    #+begin_src lisp
    (asdf:load-system "alexandria")
    #+end_src
**** asdf:make
     https://asdf.common-lisp.dev/asdf/Convenience-Functions.html
     "asdf:make" also load files like "asdf:load-system" as the default behavior,
     but system definition can change the behavior
     #+begin_src lisp
     (asdf:make "alexandria")
     #+end_src
*** standard location of systems
    ~/common-lisp/
    ~/.local/share/common-lisp/source/
*** dependency
    https://stackoverflow.com/a/19739782
    ":depends-on" keyword is used for dependencies between systems, files or etc
    systems (or files) which are depended on are loaded earlier than other systems or files
*** module
    lisp files can be split into multiple directories, then each directory become a module
    e.g. https://gitlab.common-lisp.net/alexandria/alexandria

    c.f.
    - each module doesn't need to belong to a specific package
    - symbols' belonging to packages are defined by utilities such as 'defpackage'
    - location of symbols in modules or files don't decide their packages
*** Load new system created during runtime
    https://lispcookbook.github.io/cl-cookbook/systems.html#using-the-system-you-defined
    - load the new .asd file: (load "path/to/foobar.asd"),
      or with C-c C-k in Slime to compile and load the whole file.
    - (asdf:clear-configuration) to re-process the configuration.
*** add directories where ASDF search systems
    https://asdf.common-lisp.dev/asdf/Configuring-ASDF-to-find-your-systems.html
    https://asdf.common-lisp.dev/asdf/Controlling-where-ASDF-searches-for-systems.html
    the default directories of systems:
    - ~/common-lisp/
    - ~/.local/share/common-lisp/source/.

    if you want to add another directory:
    1. make directory "~/.config/common-lisp/source-registry.conf.d/"
    2. make a file named "*.conf" in the directory
       e.g. "my-lisp.conf"
    3. add the following line into the file
       #+begin_src lisp
       (:tree "/home/user/my-lisp/")
       #+end_src
*** creating a project skeleton
    #+begin_src lisp
    (ql:quickload "cl-project")
    (cl-project:make-project #p"some/path/to/project/")  ; if you doesn't use an absolute path, the project directory is created from the current path for slime
    #+end_src
*** testing a system
    #+begin_src lisp
    (asdf:test-system :some-project)
    #+end_src

    for testing, a testing system should be defined in the system's .asd file
    (the test skeleton is also created by "cl-project:make-project")
    e.g.
    #+begin_src lisp
    (defsystem "some-project"
      ...)
    (defsystem "some-project/tests"
      ...)
    #+end_src
** quicklisp
*** install and load systems
    #+begin_src lisp
    (ql:quickload "some-system")
    #+end_src
    the system "some-system" installed in "~/quicklisp/dists/quicklisp/software/"
** comment
*** #+(or) & #+(and)
    https://stackoverflow.com/a/6365579 
    https://lispcookbook.github.io/cl-cookbook/debugging.html#using-the-powerful-repl
    #+(or) comment the following expression
    #+(and) doesn't comment the following expression
    #+begin_src lisp
    (progn
      #+(or)
      (defun func-1 ())  ; undefined
      #+(and)
      (defun func-2 ())  ; defined
      )
    #+end_src    

    ~#+nil~ works too but there are exceptional cases
    ( https://stackoverflow.com/a/6365579 )
*** #| ... |#
    https://lispcookbook.github.io/cl-cookbook/debugging.html#using-the-powerful-repl

    the code in #| ... |# is commented

* Lisp functions
** (load "file-path.ext")
** (apropos "some-substring")
   search for interned symbols whose names contain the substring
** print & read
   https://lispcookbook.github.io/cl-cookbook/debugging.html
   "print" prints a readable representation of its argument,
   which means what is printed can be read back in by the Lisp reader.
** princ
   https://lispcookbook.github.io/cl-cookbook/debugging.html
   "princ" focuses on an aesthetic representation.
** format
   "format" prints (with t as the 1st argument) or returns a string (with nil as the 1st argument)
   #+begin_src lisp
   (format t "it prints - ~a ~a" "some string" 100)  ; print a string and return nil
   (format nil "it's a string - ~a ~a" "some string" 100)  ; return a string
   #+end_src
*** iteration construct (~{str~})
    https://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node200.html
    #+begin_src lisp
    (format nil 
            "The winners are:~{ ~S~}." 
            '(fred harry jill)) 
    ;; => "The winners are: FRED HARRY JILL." 

    (format nil "Pairs:~{ <~S,~S>~}." '(a 1 b 2 c 3)) 
    ;; => "Pairs: <A,1> <B,2> <C,3>."
    #+end_src
