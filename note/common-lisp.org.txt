
* Install
  https://askubuntu.com/questions/670304/what-is-the-install-routine-for-common-lisp-slime-sbcl-quicklisp-on-ubuntu
  https://lispcookbook.github.io/cl-cookbook/getting-started.html
** install sbcl
   $ sudo apt-get install sbcl
   $ sudo apt install sbcl-source  # necessary for "slime-edit-definition" (M-.)
   or
   $ conda install -c conda-forge sbcl
** install quicklisp
   https://www.quicklisp.org/
   copy and past the code in the gray box of the website (https://www.quicklisp.org/)

   Below is the summary (written at 2020.11.19):
   $ curl -O https://beta.quicklisp.org/quicklisp.lisp
   $ curl -O https://beta.quicklisp.org/quicklisp.lisp.asc
   $ gpg --verify quicklisp.lisp.asc quicklisp.lisp
   $ sbcl --load quicklisp.lisp
   * (quicklisp-quickstart:install)
   * (ql:system-apropos "vecto")
   * (ql:quickload "vecto")
   * (ql:add-to-init-file)
   * (quit)
** install slime by using quicklisp
   $ sbcl
   * (ql:quickload "quicklisp-slime-helper")
   * (quit)
** after installing slime, it will say following:
   - To use, add this to your ~/.emacs:
     (load (expand-file-name "~/quicklisp/slime-helper.el"))
     ;; Replace "sbcl" with the path to your implementation
     (setq inferior-lisp-program "path/to/sbcl")
   - you can get the path by "which sbcl"
** M-x slime
** run a script file in command line
   $ sbcl --script source.lisp

* Debian
** library install
   https://wiki.debian.org/CommonLisp
   there are two ways to install libraries in debian
   - via apt
     - once a system has been installed, it can be loaded with "require"
       - "asdf" should be loaded beforehand by (require "asdf")?
   - via quicklisp
     - "ql:quickload" tries downloading then loads a system
     - once a system has been installed, it can be loaded with "require"
       - "quicklisp" should be loaded beforehand
       - quicklisp can be loaded by (load "~/quicklisp/setup.lisp")
         unless "~/.sbclrc" is not updated by (ql:add-to-init-file)

* SLIME
** emacs SLIME commands
   - slime : runs REPL
   - slime-repl-quit
   - slime-quit-lisp
   - M-. : go to definition from slime REPL
*** resource
    - The Common Lisp Cookbook
      https://lispcookbook.github.io/cl-cookbook/emacs-ide.html
      - slime REPL shortcuts
        https://lispcookbook.github.io/cl-cookbook/emacs-ide.html#all-slime-repl-shortcuts
      - slime mode shortcuts
        https://lispcookbook.github.io/cl-cookbook/emacs-ide.html#all-other-slime-shortcuts
    - useful slime shortcuts
      https://www.youtube.com/watch?v=sBcPNr1CKKw
** Debugging
   - (error "message" ...): shows backtrace
   - (break): go into a debugger
*** SLDB: the SLIME debugger
    https://slime.common-lisp.dev/doc/html/Debugger.html

* CFFI
  - tutorial: https://www.youtube.com/watch?v=lvHi5LyhxGk

* Note
** Function arguments
   http://www.gigamonkeys.com/book/functions.html
   addtional arguments: optional, rest, keyword
** function(#') and lambda
   https://stackoverflow.com/a/29346982/6710003

   The results of following expresions are same:
   > #'(lambda ...)
   > (function (lambda ...))
   > (lambda ...)

   because lambda is a macro and the expanded form include function:
   > (macroexpand-1 '(lambda (x) (+ x x x)))
   ==> (function (lambda (x) (+ x x x)))
** Macro
   - examples: https://lispcookbook.github.io/cl-cookbook/macros.html
** package
   https://lispcookbook.github.io/cl-cookbook/packages.html
*** current package
    a special variable ~*package*~ indicate the current package
    #+begin_src lisp
    *package*
    #+end_src
*** initial package
    common-lisp-user is the inital package
*** making a package
    a new package cange defined by 'defpackage'.
    however, the command doesn't switch to the new package.
    #+begin_src lisp
    (defpackage :my-package
      (:use :cl))
    #+end_src
*** switching package
    change the current package
    #+begin_src lisp
    (in-package :my-package)
    #+end_src
*** accessing symbols in packages
    - package:exported-symbol
    - package::non-exported-symbol.
*** importing symbols in other packages
**** importing specific symbols
     #+begin_src lisp
     (defpackage :my-package
       (:import-from :ppcre :regex-replace)
       (:use :cl))
     #+end_src
     'my-package' shares symbol 'regex-replace' with package 'ppcre'
     'import-from' can import any symbol in a package, whether the symbol is exported from the package or not.
**** importing all symbols
     #+begin_src lisp
     (defpackage :my-package
       (:use :cl :ppcre))
     #+end_src
     all symbols exported from 'cl' and 'ppcre' are available in 'my-package'.
     however, exploit 'use' only for importing symbols of your internal packages which you can control.
**** printing all exported packages
     #+begin_src lisp
     (let ((package-name "CL"))  ; the name should be capitalized
       (do-external-symbols (s (find-package package-name))
         (print s)))
     #+end_src

* Lisp functions
** (load "file-path.ext")
** (apropos "some-substring")




   search for interned symbols whose names contain the substring
